import { createRequire } from 'module';
const require = createRequire(import.meta.url);

var { default: makeWASocket, delay, useMultiFileAuthState, fetchLatestBaileysVersion, jidNormalizedUser, DisconnectReason, Browsers, makeCacheableSignalKeyStore } = require('@whiskeysockets/baileys');
import { Boom } from '@hapi/boom';
import fs from 'fs';
import pino from 'pino';
import treeKill from '../utils/tree-kill.js';
import serialize, { Client, initLidStore } from '../utils/serialize.js';
import { GroupParticipants } from './group-participants.js';
import { Messages } from './message.js';
import { saveJadiBotList, loadJadiBotList } from '../lib/jadibot-store.js';
const processedMessages = new Map();
import NodeCache from "node-cache";
//const groupCache = new NodeCache({ stdTTL: 30 * 60, useClones: false });


export const startJadiBot = (targetNumber, m) => {
    const pathSession = `./src/database/jadi/jadi-${targetNumber}`;
    const pathContacts = `${pathSession}/contacts.json`;
    const pathMetadata = `${pathSession}/groupMetadata.json`;
    const pathStore = `${pathSession}/store.json`;

    if (!fs.existsSync(pathSession)) fs.mkdirSync(pathSession, { recursive: true });

    const store = global.store;
    if (process.env.WRITE_STORE === 'true' && fs.existsSync(pathStore)) store.readFromFile(pathStore);

    const usePairingCode = targetNumber;
    const logger = pino({ timestamp: () => `,"time":"${new Date().toJSON()}"` });
    logger.level = 'fatal';

    const startBot2 = async () => {
        const { state, saveCreds } = await useMultiFileAuthState(pathSession);
        const { version } = await fetchLatestBaileysVersion();

        const sock = makeWASocket({
            version,
            logger,
            printQRInTerminal: !usePairingCode,
            auth: {
                creds: state.creds,
                keys: makeCacheableSignalKeyStore(state.keys, logger),
            },
            browser: Browsers.macOS("Safari"),
            markOnlineOnConnect: true,
            generateHighQualityLinkPreview: true,
            syncFullHistory: false,
            retryRequestDelayMs: 10,
            transactionOpts: { maxCommitRetries: 10, delayBetweenTriesMs: 10 },
            defaultQueryTimeoutMs: undefined,
            maxMsgRetryCount: 15,
            appStateMacVerification: { patch: true, snapshot: true },
            getMessage: async key => {
                const jid = jidNormalizedUser(key.remoteJid);
                const msg = await store.loadMessage(jid, key.id);
                return msg?.message || '';
            },
            shouldSyncHistoryMessage: msg => !!msg.syncType,
            // cachedGroupMetadata: async (jid) => groupCache.get(jid)
        });

        store?.bind(sock.ev);
        await Client({ client: sock, store });

        if (usePairingCode && !sock.authState.creds.registered) {
            await delay(3000);
            const code = await sock.requestPairingCode(targetNumber);
            console.log(`\x1b[32m${code?.match(/.{1,4}/g)?.join('-') || code}\x1b[39m`);
            m.reply(`${code?.match(/.{1,4}/g)?.join('-') || code}`);
        }

        sock.ev.on('connection.update', async ({ lastDisconnect, connection }) => {
            if (connection) console.info(`Connection Status : ${connection}`);

            if (connection === "close") {
                const reason = new Boom(lastDisconnect?.error)?.output.statusCode;
                if ([DisconnectReason.badSession, DisconnectReason.connectionClosed, DisconnectReason.connectionLost, DisconnectReason.connectionReplaced, DisconnectReason.restartRequired].includes(reason)) {
                    console.info("Reconnecting jadibot...");
                    startBot2();
                } else if ([DisconnectReason.loggedOut, DisconnectReason.multideviceMismatch].includes(reason)) {
                    console.error("Session jadibot Invalid, Deleting...");
                    sock.end();
                    fs.rmSync(pathSession, { recursive: true, force: true });
                    const updatedList = loadJadiBotList().filter(n => n !== targetNumber);
                    saveJadiBotList(updatedList);
                } else {
                    console.log("Unknown Disconnect Reason, Restarting jadibot...");
                    startBot2();
                }
            }

            if (connection === "open") {
                sock.sendMessage(jidNormalizedUser(sock.user.id), { text: `Bot Cabang ${sock.user?.name} Connected` });
                const updatedList = loadJadiBotList();
                if (!updatedList.includes(targetNumber)) {
                    updatedList.push(targetNumber);
                    saveJadiBotList(updatedList);
                }
                initLidStore(sock); // inisialisasi LID mapping

            }
        });

        sock.ev.on('creds.update', saveCreds);

        sock.ev.on("lid-mapping.update", (update) => { });

        if (fs.existsSync(pathContacts)) store.contacts = JSON.parse(fs.readFileSync(pathContacts, 'utf-8'));
        else fs.writeFileSync(pathContacts, JSON.stringify({}));

        if (fs.existsSync(pathMetadata)) store.groupMetadata = JSON.parse(fs.readFileSync(pathMetadata, 'utf-8'));
        else fs.writeFileSync(pathMetadata, JSON.stringify({}));

        sock.ev.on('contacts.update', update => {
            update.forEach(contact => {
                const id = jidNormalizedUser(contact.id);
                store.contacts[id] = { ...(store.contacts[id] || {}), ...(contact || {}) };
            });
        });

        sock.ev.on('contacts.upsert', update => {
            update.forEach(contact => {
                const id = jidNormalizedUser(contact.id);
                store.contacts[id] = { ...(contact || {}), isContact: true };
            });
        });

        sock.ev.on('groups.update', updates => {
            updates.forEach(update => {
                const id = update.id;
                if (store.groupMetadata[id]) {
                    store.groupMetadata[id] = { ...store.groupMetadata[id], ...update };
                    // const meta = client.groupMetadata(update.id)
                    // groupCache.set(update.id, meta);

                }
            });
        });

        sock.ev.on('group-participants.update', async (anu) => {
            await GroupParticipants(anu, sock);
            // const meta = client.groupMetadata(anu)
            // groupCache.set(anu, meta);

        });

        sock.ev.on('messages.upsert', async ({ messages }) => {
            await delay(50);
            if (!messages[0]?.message) return;
            const msg = await serialize(sock, messages[0], store);

            if (store.groupMetadata && Object.keys(store.groupMetadata).length === 0) store.groupMetadata = await sock.groupFetchAllParticipating();

            if (msg.key && !msg.key.fromMe && msg.key.remoteJid === 'status@broadcast') {
                if (msg.type === 'protocolMessage' && msg.message.protocolMessage.type === 0) return;
                await sock.readMessages([msg.key]);
            }


            if (processedMessages.has(msg.key.id)) return;
            processedMessages.set(msg.key.id, Date.now());

            if (!msg.isJadiBot && !msg.isOwner) return;

            await Messages(sock, msg);


        });


        setInterval(() => {
            fs.writeFileSync(pathContacts, JSON.stringify(store.contacts || {}));
            fs.writeFileSync(pathMetadata, JSON.stringify(store.groupMetadata || {}));
            if (process.env.WRITE_STORE === 'true') store.writeToFile(pathStore);
        }, 60000);

        setInterval(() => {
            const now = Date.now();
            fs.readdir(pathSession, (err, files) => {
                if (err) return console.error('Error reading session directory:', err);
                files.filter(file => file.startsWith('pre-key') ||
                    file.startsWith('sender-key') ||
                    file.startsWith('session-') ||
                    file.startsWith('lid-mapping-') ||
                    file.startsWith('app-state'))
                    .forEach(file => fs.unlinkSync(`${pathSession}/${file}`));
            });
            for (const [id, time] of processedMessages.entries()) {
                if (now - time > 60000) processedMessages.delete(id);
            }
        }, 10000);

        setInterval(() => {
            process.send?.('heartbeat');
        }, 60 * 1000);

        process.on('uncaughtException', console.error);
        process.on('unhandledRejection', console.error);
    };

    startBot2();
};
